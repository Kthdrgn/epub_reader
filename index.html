<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPUB3 Media Overlay Reader</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: system-ui, -apple-system, sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // Lucide Icons as inline SVG components
        const Play = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
        );

        const Pause = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <rect x="6" y="4" width="4" height="16"></rect>
                <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
        );

        const SkipBack = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <polygon points="19 20 9 12 19 4 19 20"></polygon>
                <line x1="5" y1="19" x2="5" y2="5"></line>
            </svg>
        );

        const SkipForward = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <polygon points="5 4 15 12 5 20 5 4"></polygon>
                <line x1="19" y1="5" x2="19" y2="19"></line>
            </svg>
        );

        const Upload = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
        );

        const Book = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
            </svg>
        );

        const Volume2 = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>
        );

        const Settings = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M12 1v6m0 6v6"></path>
            </svg>
        );

        const Menu = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <line x1="3" y1="12" x2="21" y2="12"></line>
                <line x1="3" y1="6" x2="21" y2="6"></line>
                <line x1="3" y1="18" x2="21" y2="18"></line>
            </svg>
        );

        const ChevronDown = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
        );

        const ChevronUp = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <polyline points="18 15 12 9 6 15"></polyline>
            </svg>
        );

        const Library = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
            </svg>
        );

        const Trash = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
        );

        const ArrowLeft = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <line x1="19" y1="12" x2="5" y2="12"></line>
                <polyline points="12 19 5 12 12 5"></polyline>
            </svg>
        );

        const AlertCircle = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
        );

        const Loader = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2">
                <line x1="12" y1="2" x2="12" y2="6"></line>
                <line x1="12" y1="18" x2="12" y2="22"></line>
                <line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line>
                <line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line>
                <line x1="2" y1="12" x2="6" y2="12"></line>
                <line x1="18" y1="12" x2="22" y2="12"></line>
                <line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line>
                <line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>
            </svg>
        );

        function EPUBReader() {
            const [viewMode, setViewMode] = useState('library'); // 'library' or 'reader'
            const [epubLoaded, setEpubLoaded] = useState(false);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentText, setCurrentText] = useState('');
            const [bookTitle, setBookTitle] = useState('');
            const [currentChapter, setCurrentChapter] = useState(0);
            const [totalChapters, setTotalChapters] = useState(0);
            const [playbackRate, setPlaybackRate] = useState(1.0);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');
            const [epubData, setEpubData] = useState(null);
            const [audioBlob, setAudioBlob] = useState(null);
            const [chapterMenuOpen, setChapterMenuOpen] = useState(false);
            const [coverImage, setCoverImage] = useState(null);
            const [fileInputKey, setFileInputKey] = useState(Date.now());
            
            const audioRef = useRef(null);
            const fileInputRef = useRef(null);
            const contentRef = useRef(null);
            const zipRef = useRef(null);

            // Trigger file upload
            const triggerFileUpload = () => {
                if (fileInputRef.current) {
                    fileInputRef.current.value = ''; // Clear the value first
                    fileInputRef.current.click();
                }
            };

            // Save reading position to localStorage
            const saveReadingPosition = (bookId, chapterIndex, audioTime) => {
                const position = {
                    chapter: chapterIndex,
                    time: audioTime,
                    timestamp: Date.now()
                };
                localStorage.setItem(`epub-position-${bookId}`, JSON.stringify(position));
            };

            // Load reading position from localStorage
            const loadReadingPosition = (bookId) => {
                try {
                    const saved = localStorage.getItem(`epub-position-${bookId}`);
                    return saved ? JSON.parse(saved) : null;
                } catch (e) {
                    console.error('Error loading position:', e);
                    return null;
                }
            };

            // Generate a simple book ID from title
            const generateBookId = (title) => {
                return title.toLowerCase().replace(/[^a-z0-9]/g, '-').substring(0, 50);
            };

            // Save book to library
            const saveBookToLibrary = (title, coverImage, totalChapters) => {
                try {
                    const books = JSON.parse(localStorage.getItem('epub-library') || '[]');
                    const bookId = generateBookId(title);
                    
                    // Check if book already exists
                    const existingIndex = books.findIndex(b => b.id === bookId);
                    
                    const bookData = {
                        id: bookId,
                        title: title,
                        cover: coverImage,
                        totalChapters: totalChapters,
                        lastOpened: Date.now()
                    };
                    
                    if (existingIndex >= 0) {
                        books[existingIndex] = bookData;
                    } else {
                        books.push(bookData);
                    }
                    
                    localStorage.setItem('epub-library', JSON.stringify(books));
                } catch (e) {
                    console.error('Error saving book to library:', e);
                }
            };

            // Get all books from library
            const getLibraryBooks = () => {
                try {
                    const books = JSON.parse(localStorage.getItem('epub-library') || '[]');
                    // Sort by last opened
                    return books.sort((a, b) => b.lastOpened - a.lastOpened);
                } catch (e) {
                    console.error('Error loading library:', e);
                    return [];
                }
            };

            // Remove book from library
            const removeBookFromLibrary = (bookId) => {
                try {
                    const books = JSON.parse(localStorage.getItem('epub-library') || '[]');
                    const filtered = books.filter(b => b.id !== bookId);
                    localStorage.setItem('epub-library', JSON.stringify(filtered));
                    // Also remove reading position
                    localStorage.removeItem(`epub-position-${bookId}`);
                } catch (e) {
                    console.error('Error removing book:', e);
                }
            };

            // Get progress for a book
            const getBookProgress = (bookId, totalChapters) => {
                const position = loadReadingPosition(bookId);
                if (!position || !totalChapters) return 0;
                return Math.round(((position.chapter + 1) / totalChapters) * 100);
            };

            // Parse SMIL (Synchronized Multimedia Integration Language) file
            const parseSMIL = (smilContent) => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(smilContent, 'text/xml');
                const overlays = [];

                const parElements = doc.querySelectorAll('par');
                parElements.forEach(par => {
                    const text = par.querySelector('text');
                    const audio = par.querySelector('audio');
                    
                    if (text && audio) {
                        const textSrc = text.getAttribute('src');
                        const fragmentId = textSrc ? textSrc.split('#')[1] : null;
                        const clipBegin = audio.getAttribute('clipBegin') || audio.getAttribute('clip-begin');
                        const clipEnd = audio.getAttribute('clipEnd') || audio.getAttribute('clip-end');
                        
                        if (fragmentId && clipBegin && clipEnd) {
                            overlays.push({
                                id: fragmentId,
                                audioStart: parseTimeValue(clipBegin),
                                audioEnd: parseTimeValue(clipEnd)
                            });
                        }
                    }
                });

                return overlays;
            };

            // Parse time values from SMIL (supports formats like "0.5s", "1:30.5", "12.345")
            const parseTimeValue = (timeStr) => {
                if (!timeStr) return 0;
                
                // Remove 's' suffix if present
                timeStr = timeStr.replace('s', '');
                
                // Handle clock format (HH:MM:SS or MM:SS)
                if (timeStr.includes(':')) {
                    const parts = timeStr.split(':').map(parseFloat);
                    if (parts.length === 3) {
                        return parts[0] * 3600 + parts[1] * 60 + parts[2];
                    } else if (parts.length === 2) {
                        return parts[0] * 60 + parts[1];
                    }
                }
                
                return parseFloat(timeStr) || 0;
            };

            // Parse OPF package document
            const parseOPF = async (opfContent, opfPath) => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(opfContent, 'text/xml');
                
                // Get book title
                const titleEl = doc.querySelector('metadata title, title');
                const title = titleEl ? titleEl.textContent : 'Unknown Book';
                
                // Get spine items (reading order)
                const spine = doc.querySelector('spine');
                const itemrefs = spine ? Array.from(spine.querySelectorAll('itemref')) : [];
                
                // Get manifest items
                const manifest = doc.querySelector('manifest');
                const items = manifest ? Array.from(manifest.querySelectorAll('item')) : [];
                
                // Build item map
                const itemMap = {};
                items.forEach(item => {
                    itemMap[item.getAttribute('id')] = {
                        href: item.getAttribute('href'),
                        mediaType: item.getAttribute('media-type'),
                        mediaOverlay: item.getAttribute('media-overlay')
                    };
                });
                
                // Build chapters with media overlays
                const chapters = [];
                let chapterNumber = 1;
                for (const itemref of itemrefs) {
                    const idref = itemref.getAttribute('idref');
                    const item = itemMap[idref];
                    
                    if (item && item.mediaType && item.mediaType.includes('html')) {
                        const overlayId = item.mediaOverlay;
                        let overlays = [];
                        let audioHref = null;
                        
                        // Get media overlay SMIL file
                        if (overlayId && itemMap[overlayId]) {
                            const smilHref = itemMap[overlayId].href;
                            const smilPath = resolvePath(opfPath, smilHref);
                            
                            try {
                                const smilFile = await zipRef.current.file(smilPath).async('string');
                                overlays = parseSMIL(smilFile);
                                
                                // Extract audio file reference from SMIL
                                const smilDoc = new DOMParser().parseFromString(smilFile, 'text/xml');
                                const audioEl = smilDoc.querySelector('audio');
                                if (audioEl) {
                                    const audioSrc = audioEl.getAttribute('src');
                                    audioHref = resolvePath(smilPath.substring(0, smilPath.lastIndexOf('/')), audioSrc);
                                }
                            } catch (e) {
                                console.error('Error parsing SMIL:', e);
                            }
                        }
                        
                        // Extract chapter title from HTML if possible
                        let chapterTitle = `Chapter ${chapterNumber}`;
                        try {
                            const htmlContent = await zipRef.current.file(resolvePath(opfPath, item.href)).async('string');
                            const htmlDoc = new DOMParser().parseFromString(htmlContent, 'text/html');
                            const h1 = htmlDoc.querySelector('h1');
                            const h2 = htmlDoc.querySelector('h2');
                            const titleTag = htmlDoc.querySelector('title');
                            
                            if (h1 && h1.textContent.trim()) {
                                chapterTitle = h1.textContent.trim();
                            } else if (h2 && h2.textContent.trim()) {
                                chapterTitle = h2.textContent.trim();
                            } else if (titleTag && titleTag.textContent.trim()) {
                                chapterTitle = titleTag.textContent.trim();
                            }
                        } catch (e) {
                            console.error('Error extracting chapter title:', e);
                        }
                        
                        chapters.push({
                            id: idref,
                            href: resolvePath(opfPath, item.href),
                            overlays: overlays,
                            audioHref: audioHref,
                            title: chapterTitle
                        });
                        
                        chapterNumber++;
                    }
                }
                
                return { title, chapters };
            };

            // Resolve relative paths
            const resolvePath = (base, relative) => {
                const baseParts = base.split('/');
                baseParts.pop(); // Remove filename
                const relativeParts = relative.split('/');
                
                relativeParts.forEach(part => {
                    if (part === '..') {
                        baseParts.pop();
                    } else if (part !== '.') {
                        baseParts.push(part);
                    }
                });
                
                return baseParts.join('/');
            };

            // Find container.xml and get OPF path
            const findOPF = async (zip) => {
                try {
                    const containerXml = await zip.file('META-INF/container.xml').async('string');
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(containerXml, 'text/xml');
                    const rootfile = doc.querySelector('rootfile');
                    return rootfile ? rootfile.getAttribute('full-path') : null;
                } catch (e) {
                    console.error('Error finding OPF:', e);
                    return null;
                }
            };

            // Extract cover image from EPUB
            const extractCoverImage = async (opfContent, opfPath, zip) => {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(opfContent, 'text/xml');
                    
                    // Method 1: Look for cover in metadata
                    const coverMeta = doc.querySelector('meta[name="cover"]');
                    if (coverMeta) {
                        const coverId = coverMeta.getAttribute('content');
                        const coverItem = doc.querySelector(`item[id="${coverId}"]`);
                        if (coverItem) {
                            const coverHref = coverItem.getAttribute('href');
                            const coverPath = resolvePath(opfPath, coverHref);
                            const imageBlob = await zip.file(coverPath).async('blob');
                            return URL.createObjectURL(imageBlob);
                        }
                    }
                    
                    // Method 2: Look for item with properties="cover-image"
                    const coverItem = doc.querySelector('item[properties*="cover-image"]');
                    if (coverItem) {
                        const coverHref = coverItem.getAttribute('href');
                        const coverPath = resolvePath(opfPath, coverHref);
                        const imageBlob = await zip.file(coverPath).async('blob');
                        return URL.createObjectURL(imageBlob);
                    }
                    
                    // Method 3: Look for common cover file names
                    const commonNames = ['cover.jpg', 'cover.jpeg', 'cover.png', 'cover.gif'];
                    for (const name of commonNames) {
                        const file = zip.file(new RegExp(name, 'i'));
                        if (file && file.length > 0) {
                            const imageBlob = await file[0].async('blob');
                            return URL.createObjectURL(imageBlob);
                        }
                    }
                    
                    return null;
                } catch (e) {
                    console.error('Error extracting cover:', e);
                    return null;
                }
            };

            // Handle EPUB file upload
            const handleFileUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                if (!file.name.endsWith('.epub')) {
                    setError('Please select a valid EPUB file');
                    return;
                }

                setLoading(true);
                setError('');
                setEpubLoaded(false);

                try {
                    const zip = await JSZip.loadAsync(file);
                    zipRef.current = zip;

                    // Find and parse OPF
                    const opfPath = await findOPF(zip);
                    if (!opfPath) {
                        throw new Error('Could not find OPF package document');
                    }

                    const opfContent = await zip.file(opfPath).async('string');
                    const basePath = opfPath.substring(0, opfPath.lastIndexOf('/'));
                    const { title, chapters } = await parseOPF(opfContent, opfPath);

                    if (chapters.length === 0) {
                        throw new Error('No chapters with media overlays found in this EPUB');
                    }

                    // Extract cover image
                    const cover = await extractCoverImage(opfContent, opfPath, zip);
                    setCoverImage(cover);

                    setBookTitle(title);
                    setEpubData({ chapters, zip, basePath });
                    setTotalChapters(chapters.length);
                    
                    // Save book to library
                    saveBookToLibrary(title, cover, chapters.length);
                    
                    // Check for saved reading position
                    const bookId = generateBookId(title);
                    const savedPosition = loadReadingPosition(bookId);
                    
                    if (savedPosition && savedPosition.chapter < chapters.length) {
                        // Load saved chapter
                        await loadChapter(savedPosition.chapter, { chapters, zip, basePath });
                        
                        // Restore audio position after audio is loaded
                        if (audioRef.current) {
                            const restorePosition = () => {
                                audioRef.current.currentTime = savedPosition.time || 0;
                                audioRef.current.removeEventListener('loadedmetadata', restorePosition);
                            };
                            
                            if (audioRef.current.readyState >= 1) {
                                // Audio metadata already loaded
                                audioRef.current.currentTime = savedPosition.time || 0;
                            } else {
                                // Wait for audio to load
                                audioRef.current.addEventListener('loadedmetadata', restorePosition);
                            }
                        }
                    } else {
                        // Load first chapter
                        await loadChapter(0, { chapters, zip, basePath });
                    }
                    
                    setEpubLoaded(true);
                    setLoading(false);
                    setViewMode('reader');
                } catch (err) {
                    console.error('Error parsing EPUB:', err);
                    setError(err.message || 'Failed to load EPUB file. Make sure it has media overlays.');
                    setLoading(false);
                }
            };

            // Load a chapter
            const loadChapter = async (index, data = epubData) => {
                if (!data || index < 0 || index >= data.chapters.length) return;

                const chapter = data.chapters[index];
                
                try {
                    // Stop current playback
                    if (audioRef.current) {
                        audioRef.current.pause();
                    }
                    setIsPlaying(false);
                    
                    // Load content
                    const contentHtml = await data.zip.file(chapter.href).async('string');
                    
                    // Parse and extract body content
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(contentHtml, 'text/html');
                    const body = doc.querySelector('body');
                    
                    // Fix image paths in the content
                    const contentToUse = body || doc.documentElement;
                    const images = contentToUse.querySelectorAll('img');
                    
                    for (const img of images) {
                        const src = img.getAttribute('src');
                        if (src && !src.startsWith('data:') && !src.startsWith('http')) {
                            // Resolve the image path relative to the chapter
                            const chapterDir = chapter.href.substring(0, chapter.href.lastIndexOf('/'));
                            const imagePath = resolvePath(chapterDir, src);
                            
                            try {
                                const imageFile = data.zip.file(imagePath);
                                if (imageFile) {
                                    const imageBlob = await imageFile.async('blob');
                                    const imageUrl = URL.createObjectURL(imageBlob);
                                    img.setAttribute('src', imageUrl);
                                }
                            } catch (e) {
                                console.error('Error loading image:', imagePath, e);
                            }
                        }
                    }
                    
                    if (body) {
                        setCurrentText(body.innerHTML);
                    } else {
                        setCurrentText(contentToUse.innerHTML);
                    }

                    // Load audio if available
                    if (chapter.audioHref) {
                        try {
                            const audioData = await data.zip.file(chapter.audioHref).async('blob');
                            const audioUrl = URL.createObjectURL(audioData);
                            
                            if (audioRef.current) {
                                // Clean up old audio URL
                                if (audioBlob) {
                                    URL.revokeObjectURL(audioBlob);
                                }
                                
                                audioRef.current.src = audioUrl;
                                audioRef.current.load();
                                
                                // Wait for audio to be ready
                                await new Promise((resolve) => {
                                    const onCanPlay = () => {
                                        audioRef.current.removeEventListener('canplay', onCanPlay);
                                        resolve();
                                    };
                                    audioRef.current.addEventListener('canplay', onCanPlay);
                                });
                            }
                            
                            setAudioBlob(audioUrl);
                        } catch (e) {
                            console.error('Error loading audio:', e);
                        }
                    }

                    setCurrentChapter(index);
                } catch (err) {
                    console.error('Error loading chapter:', err);
                    setError('Failed to load chapter content');
                }
            };

            // Highlight text based on audio time
            useEffect(() => {
                if (!audioRef.current || !epubLoaded || !epubData) return;

                const audio = audioRef.current;
                
                const handleTimeUpdate = () => {
                    const currentTime = audio.currentTime;
                    const chapter = epubData.chapters[currentChapter];
                    
                    if (!chapter || !chapter.overlays) return;

                    const currentOverlay = chapter.overlays.find(
                        overlay => currentTime >= overlay.audioStart && currentTime < overlay.audioEnd
                    );

                    if (currentOverlay) {
                        highlightText(currentOverlay.id);
                    }
                    
                    // Save position every 5 seconds
                    if (Math.floor(currentTime) % 5 === 0 && bookTitle) {
                        const bookId = generateBookId(bookTitle);
                        saveReadingPosition(bookId, currentChapter, currentTime);
                    }
                };

                const handleEnded = () => {
                    setIsPlaying(false);
                    if (currentChapter < totalChapters - 1) {
                        nextChapter();
                    }
                };
                
                const handleLoadedMetadata = () => {
                    // Trigger initial highlight when audio loads
                    const currentTime = audio.currentTime;
                    const chapter = epubData.chapters[currentChapter];
                    
                    if (chapter && chapter.overlays) {
                        const currentOverlay = chapter.overlays.find(
                            overlay => currentTime >= overlay.audioStart && currentTime < overlay.audioEnd
                        );
                        if (currentOverlay) {
                            highlightText(currentOverlay.id);
                        }
                    }
                };

                audio.addEventListener('timeupdate', handleTimeUpdate);
                audio.addEventListener('ended', handleEnded);
                audio.addEventListener('loadedmetadata', handleLoadedMetadata);
                audio.addEventListener('seeked', handleLoadedMetadata);

                return () => {
                    audio.removeEventListener('timeupdate', handleTimeUpdate);
                    audio.removeEventListener('ended', handleEnded);
                    audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                    audio.removeEventListener('seeked', handleLoadedMetadata);
                };
            }, [currentChapter, epubLoaded, epubData, bookTitle]);

            const highlightText = (elementId) => {
                if (!contentRef.current) return;
                
                const allElements = contentRef.current.querySelectorAll('[id]');
                allElements.forEach(el => {
                    el.style.backgroundColor = 'transparent';
                    el.style.color = '';
                    el.style.transition = 'all 0.3s ease';
                });

                const element = contentRef.current.querySelector(`#${elementId}`);
                if (element) {
                    element.style.backgroundColor = '#fbbf24';
                    element.style.color = '#1e293b';
                    element.style.fontWeight = '600';
                    element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            };

            const togglePlayPause = () => {
                if (!audioRef.current) return;

                if (isPlaying) {
                    audioRef.current.pause();
                    setIsPlaying(false);
                } else {
                    audioRef.current.play().then(() => {
                        setIsPlaying(true);
                    }).catch(err => {
                        console.error('Error playing audio:', err);
                        setIsPlaying(false);
                    });
                }
            };

            const nextChapter = () => {
                if (currentChapter < totalChapters - 1) {
                    loadChapter(currentChapter + 1);
                    // Save position when changing chapters
                    if (bookTitle) {
                        const bookId = generateBookId(bookTitle);
                        saveReadingPosition(bookId, currentChapter + 1, 0);
                    }
                }
            };

            const previousChapter = () => {
                if (currentChapter > 0) {
                    loadChapter(currentChapter - 1);
                    // Save position when changing chapters
                    if (bookTitle) {
                        const bookId = generateBookId(bookTitle);
                        saveReadingPosition(bookId, currentChapter - 1, 0);
                    }
                }
            };

            const changePlaybackRate = (rate) => {
                setPlaybackRate(rate);
                if (audioRef.current) {
                    audioRef.current.playbackRate = rate;
                }
            };

            const handleElementClick = (e) => {
                if (!epubData) return;
                
                const clickedElement = e.target.closest('[id]');
                if (!clickedElement) return;

                const elementId = clickedElement.id;
                const chapter = epubData.chapters[currentChapter];
                const overlay = chapter.overlays.find(o => o.id === elementId);

                if (overlay && audioRef.current) {
                    audioRef.current.currentTime = overlay.audioStart;
                    if (!isPlaying) {
                        audioRef.current.play();
                        setIsPlaying(true);
                    }
                }
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-white">
                    {viewMode === 'library' ? (
                        <LibraryView 
                            onUpload={triggerFileUpload}
                            onSelectBook={handleFileUpload}
                            getLibraryBooks={getLibraryBooks}
                            removeBookFromLibrary={removeBookFromLibrary}
                            getBookProgress={getBookProgress}
                            loading={loading}
                        />
                    ) : (
                        <ReaderView 
                            epubLoaded={epubLoaded}
                            bookTitle={bookTitle}
                            coverImage={coverImage}
                            currentChapter={currentChapter}
                            totalChapters={totalChapters}
                            isPlaying={isPlaying}
                            playbackRate={playbackRate}
                            error={error}
                            loading={loading}
                            epubData={epubData}
                            currentText={currentText}
                            chapterMenuOpen={chapterMenuOpen}
                            setChapterMenuOpen={setChapterMenuOpen}
                            loadChapter={loadChapter}
                            contentRef={contentRef}
                            handleElementClick={handleElementClick}
                            previousChapter={previousChapter}
                            togglePlayPause={togglePlayPause}
                            nextChapter={nextChapter}
                            changePlaybackRate={changePlaybackRate}
                            audioRef={audioRef}
                            fileInputRef={fileInputRef}
                            handleFileUpload={handleFileUpload}
                            onBackToLibrary={() => setViewMode('library')}
                            triggerFileUpload={triggerFileUpload}
                        />
                    )}
                    <input
                        key={fileInputKey}
                        ref={fileInputRef}
                        type="file"
                        accept=".epub"
                        onChange={handleFileUpload}
                        className="hidden"
                    />
                </div>
            );
        }

        function LibraryView({ onUpload, getLibraryBooks, removeBookFromLibrary, getBookProgress, loading }) {
            const [books, setBooks] = React.useState([]);

            React.useEffect(() => {
                setBooks(getLibraryBooks());
            }, []);

            const handleRemoveBook = (bookId, e) => {
                e.stopPropagation();
                if (confirm('Are you sure you want to remove this book from your library?')) {
                    removeBookFromLibrary(bookId);
                    setBooks(getLibraryBooks());
                }
            };

            const handleBookClick = (book, e) => {
                // Open file picker to re-upload the book
                // Progress will be restored automatically
                onUpload();
            };

            return (
                <div>
                    <div className="bg-slate-800/50 backdrop-blur-sm border-b border-slate-700">
                        <div className="max-w-6xl mx-auto px-4 py-4">
                            <div className="flex items-center justify-between">
                                <div className="flex items-center gap-3">
                                    <Library className="w-8 h-8 text-amber-400" />
                                    <div>
                                        <h1 className="text-xl font-bold">My Library</h1>
                                        <p className="text-sm text-slate-400">
                                            {books.length} {books.length === 1 ? 'book' : 'books'}
                                        </p>
                                    </div>
                                </div>
                                
                                <button
                                    onClick={onUpload}
                                    disabled={loading}
                                    className="flex items-center gap-2 px-4 py-2 bg-amber-500 hover:bg-amber-600 disabled:bg-slate-600 disabled:cursor-not-allowed rounded-lg transition-colors"
                                >
                                    {loading ? <Loader className="w-4 h-4 animate-spin" /> : <Upload className="w-4 h-4" />}
                                    {loading ? 'Loading...' : 'Add Book'}
                                </button>
                            </div>
                        </div>
                    </div>

                    <div className="max-w-6xl mx-auto px-4 py-8">
                        {books.length === 0 ? (
                            <div className="text-center py-20">
                                <Library className="w-20 h-20 text-amber-400 mx-auto mb-6" />
                                <h2 className="text-2xl font-bold mb-4">Your Library is Empty</h2>
                                <p className="text-slate-400 mb-8 max-w-md mx-auto">
                                    Upload your first EPUB3 book with media overlays to start building your collection.
                                </p>
                                <button
                                    onClick={onUpload}
                                    className="px-6 py-3 bg-amber-500 hover:bg-amber-600 rounded-lg transition-colors font-semibold"
                                >
                                    Add Your First Book
                                </button>
                            </div>
                        ) : (
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                                {books.map(book => {
                                    const progress = getBookProgress(book.id, book.totalChapters);
                                    return (
                                        <div
                                            key={book.id}
                                            onClick={(e) => handleBookClick(book, e)}
                                            className="bg-slate-800/50 backdrop-blur rounded-xl border border-slate-700 overflow-hidden hover:border-amber-500/50 transition-all cursor-pointer group"
                                        >
                                            <div className="relative aspect-[2/3] bg-slate-700">
                                                {book.cover ? (
                                                    <img 
                                                        src={book.cover} 
                                                        alt={book.title}
                                                        className="w-full h-full object-cover"
                                                    />
                                                ) : (
                                                    <div className="w-full h-full flex items-center justify-center">
                                                        <Book className="w-16 h-16 text-slate-500" />
                                                    </div>
                                                )}
                                                <button
                                                    onClick={(e) => handleRemoveBook(book.id, e)}
                                                    className="absolute top-2 right-2 p-2 bg-red-500/80 hover:bg-red-600 rounded-full opacity-0 group-hover:opacity-100 transition-opacity"
                                                >
                                                    <Trash className="w-4 h-4" />
                                                </button>
                                            </div>
                                            <div className="p-4">
                                                <h3 className="font-semibold mb-2 line-clamp-2">{book.title}</h3>
                                                <div className="space-y-2">
                                                    <div className="flex justify-between text-sm text-slate-400">
                                                        <span>{book.totalChapters} chapters</span>
                                                        <span>{progress}%</span>
                                                    </div>
                                                    <div className="w-full bg-slate-700 rounded-full h-2">
                                                        <div 
                                                            className="bg-amber-500 h-2 rounded-full transition-all"
                                                            style={{ width: `${progress}%` }}
                                                        />
                                                    </div>
                                                    <p className="text-xs text-slate-500">
                                                        Last opened: {new Date(book.lastOpened).toLocaleDateString()}
                                                    </p>
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function ReaderView({ 
            epubLoaded, bookTitle, coverImage, currentChapter, totalChapters, 
            isPlaying, playbackRate, error, loading, epubData, currentText, 
            chapterMenuOpen, setChapterMenuOpen, loadChapter, contentRef, 
            handleElementClick, previousChapter, togglePlayPause, nextChapter, 
            changePlaybackRate, audioRef, fileInputRef, handleFileUpload, onBackToLibrary,
            triggerFileUpload
        }) {
            return (
                <div>
                    <div className="bg-slate-800/50 backdrop-blur-sm border-b border-slate-700 sticky top-0 z-10">
                        <div className="max-w-6xl mx-auto px-4 py-4">
                            <div className="flex items-center justify-between">
                                <div className="flex items-center gap-3">
                                    <button
                                        onClick={onBackToLibrary}
                                        className="p-2 hover:bg-slate-700 rounded-lg transition-colors"
                                        title="Back to Library"
                                    >
                                        <ArrowLeft className="w-5 h-5" />
                                    </button>
                                    {coverImage && (
                                        <img 
                                            src={coverImage} 
                                            alt="Book cover" 
                                            className="w-12 h-16 object-cover rounded shadow-lg"
                                        />
                                    )}
                                    {!coverImage && <Book className="w-8 h-8 text-amber-400" />}
                                    <div>
                                        <h1 className="text-xl font-bold">{bookTitle || 'EPUB3 Reader'}</h1>
                                        <p className="text-sm text-slate-400">
                                            {epubLoaded ? `Chapter ${currentChapter + 1} of ${totalChapters}` : 'Upload an EPUB3 file to begin'}
                                        </p>
                                    </div>
                                </div>
                                
                                <button
                                    onClick={triggerFileUpload}
                                    disabled={loading}
                                    className="flex items-center gap-2 px-4 py-2 bg-amber-500 hover:bg-amber-600 disabled:bg-slate-600 disabled:cursor-not-allowed rounded-lg transition-colors"
                                >
                                    {loading ? <Loader className="w-4 h-4 animate-spin" /> : <Upload className="w-4 h-4" />}
                                    {loading ? 'Loading...' : 'Upload EPUB'}
                                </button>
                            </div>
                        </div>
                    </div>

                    <div className="max-w-4xl mx-auto px-4 py-8">
                        {error && (
                            <div className="bg-red-900/30 border border-red-700 rounded-xl p-4 mb-6 flex items-start gap-3">
                                <AlertCircle className="w-5 h-5 text-red-400 flex-shrink-0 mt-0.5" />
                                <div>
                                    <h3 className="font-semibold text-red-200 mb-1">Error</h3>
                                    <p className="text-red-300 text-sm">{error}</p>
                                </div>
                            </div>
                        )}

                        {epubLoaded ? (
                            <div className="space-y-6">
                                {/* Chapter Navigation Menu */}
                                <div className="bg-slate-800/50 backdrop-blur rounded-xl border border-slate-700 overflow-hidden">
                                    <button
                                        onClick={() => setChapterMenuOpen(!chapterMenuOpen)}
                                        className="w-full flex items-center justify-between p-4 hover:bg-slate-700/50 transition-colors"
                                    >
                                        <div className="flex items-center gap-2">
                                            <Menu className="w-5 h-5 text-amber-400" />
                                            <span className="font-semibold">Chapters</span>
                                        </div>
                                        {chapterMenuOpen ? (
                                            <ChevronUp className="w-5 h-5 text-slate-400" />
                                        ) : (
                                            <ChevronDown className="w-5 h-5 text-slate-400" />
                                        )}
                                    </button>
                                    
                                    {chapterMenuOpen && (
                                        <div className="border-t border-slate-700 max-h-64 overflow-y-auto">
                                            {epubData.chapters.map((chapter, index) => (
                                                <button
                                                    key={index}
                                                    onClick={() => {
                                                        loadChapter(index);
                                                        setChapterMenuOpen(false);
                                                    }}
                                                    className={`w-full text-left px-4 py-3 hover:bg-slate-700/50 transition-colors border-b border-slate-700/50 last:border-b-0 ${
                                                        currentChapter === index ? 'bg-amber-500/20 border-l-4 border-l-amber-500' : ''
                                                    }`}
                                                >
                                                    <div className="flex items-center justify-between">
                                                        <span className={currentChapter === index ? 'text-amber-400 font-semibold' : 'text-slate-300'}>
                                                            {chapter.title || `Chapter ${index + 1}`}
                                                        </span>
                                                        {currentChapter === index && (
                                                            <span className="text-xs text-amber-400">Playing</span>
                                                        )}
                                                    </div>
                                                </button>
                                            ))}
                                        </div>
                                    )}
                                </div>

                                <div 
                                    ref={contentRef}
                                    onClick={handleElementClick}
                                    className="bg-slate-800/30 backdrop-blur rounded-xl p-8 shadow-2xl border border-slate-700 cursor-pointer prose prose-invert max-w-none overflow-y-auto"
                                    style={{ lineHeight: '1.8', fontSize: '18px', maxHeight: '60vh' }}
                                    dangerouslySetInnerHTML={{ __html: currentText }}
                                />

                                <div className="bg-slate-800/50 backdrop-blur rounded-xl p-6 border border-slate-700">
                                    <div className="flex items-center justify-center gap-4 mb-4">
                                        <button
                                            onClick={previousChapter}
                                            disabled={currentChapter === 0}
                                            className="p-3 bg-slate-700 hover:bg-slate-600 disabled:bg-slate-800 disabled:text-slate-600 rounded-full transition-colors"
                                        >
                                            <SkipBack className="w-5 h-5" />
                                        </button>
                                        
                                        <button
                                            onClick={togglePlayPause}
                                            className="p-4 bg-amber-500 hover:bg-amber-600 rounded-full transition-colors"
                                        >
                                            {isPlaying ? <Pause className="w-6 h-6" /> : <Play className="w-6 h-6" />}
                                        </button>
                                        
                                        <button
                                            onClick={nextChapter}
                                            disabled={currentChapter === totalChapters - 1}
                                            className="p-3 bg-slate-700 hover:bg-slate-600 disabled:bg-slate-800 disabled:text-slate-600 rounded-full transition-colors"
                                        >
                                            <SkipForward className="w-5 h-5" />
                                        </button>
                                    </div>

                                    <div className="flex items-center justify-center gap-4 mt-4">
                                        <Volume2 className="w-5 h-5 text-slate-400" />
                                        <div className="flex gap-2">
                                            {[0.5, 0.75, 1.0, 1.25, 1.5, 2.0].map(rate => (
                                                <button
                                                    key={rate}
                                                    onClick={() => changePlaybackRate(rate)}
                                                    className={`px-3 py-1 rounded ${
                                                        playbackRate === rate
                                                            ? 'bg-amber-500 text-white'
                                                            : 'bg-slate-700 hover:bg-slate-600 text-slate-300'
                                                    } text-sm transition-colors`}
                                                >
                                                    {rate}x
                                                </button>
                                            ))}
                                        </div>
                                    </div>

                                    <audio ref={audioRef} preload="auto" />
                                    
                                    <p className="text-center text-slate-400 text-sm mt-4">
                                        Click on any text to jump to that narration point
                                    </p>
                                </div>

                                <div className="bg-slate-800/30 backdrop-blur rounded-xl p-6 border border-slate-700">
                                    <h3 className="text-lg font-semibold mb-3 flex items-center gap-2">
                                        <Settings className="w-5 h-5 text-amber-400" />
                                        How It Works
                                    </h3>
                                    <div className="text-slate-300 space-y-2 text-sm">
                                        <p>• This reader parses EPUB3 files and extracts media overlay information</p>
                                        <p>• Text highlights automatically as synchronized audio plays</p>
                                        <p>• Click any text element to jump to that narration point</p>
                                        <p>• Navigate between chapters with the arrow buttons</p>
                                        <p>• Adjust playback speed to your preference</p>
                                    </div>
                                </div>
                            </div>
                        ) : (
                            <div className="text-center py-20">
                                <Book className="w-20 h-20 text-amber-400 mx-auto mb-6" />
                                <h2 className="text-2xl font-bold mb-4">Welcome to EPUB3 Reader</h2>
                                <p className="text-slate-400 mb-8 max-w-md mx-auto">
                                    Upload an EPUB3 file with media overlays to experience synchronized reading and listening.
                                    The file will be processed entirely in your browser.
                                </p>
                                <div className="bg-slate-800/50 rounded-xl p-6 max-w-2xl mx-auto text-left">
                                    <h3 className="font-semibold mb-3 text-amber-400">Requirements:</h3>
                                    <ul className="text-slate-300 space-y-2 text-sm list-disc list-inside">
                                        <li>EPUB3 format file (.epub)</li>
                                        <li>Must contain media overlays (SMIL files)</li>
                                        <li>Embedded audio files synchronized with text</li>
                                        <li>Valid package document (OPF) structure</li>
                                    </ul>
                                    <p className="text-slate-400 text-xs mt-4">
                                        Note: Books generated by Storyteller platform are fully compatible.
                                    </p>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<EPUBReader />, document.getElementById('root'));
    </script>

    <style>
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
    </style>
</body>
</html>